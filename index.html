<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>harpoon</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'><rect width='32' height='32' fill='%23743bed'/><rect x='4' y='8' width='24' height='16' fill='none' stroke='%23ffffff' stroke-width='1.5'/><rect x='6' y='10' width='20' height='4' fill='%23ffffff' opacity='0.3'/><rect x='6' y='18' width='20' height='4' fill='%23ffffff' opacity='0.3'/><circle cx='10' cy='16' r='1.5' fill='%23ffffff'/><line x1='12' y1='16' x2='16' y2='12' stroke='%23ffffff' stroke-width='1'/><line x1='12' y1='16' x2='16' y2='20' stroke='%23ffffff' stroke-width='1'/><line x1='16' y1='12' x2='20' y2='16' stroke='%23ffffff' stroke-width='1'/><line x1='16' y1='20' x2='20' y2='16' stroke='%23ffffff' stroke-width='1'/><circle cx='20' cy='16' r='1.5' fill='%23ffffff'/></svg>">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/4.3.0/marked.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
            font-weight: 300;
            background: linear-gradient(180deg, #0a0a0f 0%, #1a1a1f 100%);
            color: #e8e8e8;
            height: 100vh;
            display: flex;
            flex-direction: column;
            font-size: 16px;
            line-height: 1.6;
        }

        .header {
            padding: 3rem 3rem 2rem 3rem;
            background: linear-gradient(180deg, rgba(26,26,26,0.95) 0%, rgba(26,26,26,0) 100%);
            backdrop-filter: blur(20px);
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            overflow: hidden;
        }

        .header.collapsed {
            padding: 1.5rem 3rem;
        }

        .header h1 {
            font-size: 2.5rem;
            font-weight: 100;
            color: #ffffff;
            margin-bottom: 2rem;
            letter-spacing: -0.02em;
            opacity: 0;
            animation: fadeInUp 0.8s ease forwards;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }

        .header h1:hover {
            color: rgba(255,255,255,0.8);
        }

        .header h1::after {
            content: '⌄';
            position: absolute;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            font-size: 1.5rem;
            opacity: 0.5;
            transition: all 0.3s ease;
        }

        .header.collapsed h1::after {
            transform: translateY(-50%) rotate(-90deg);
        }

        .header-config {
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            transform-origin: top;
        }

        .header.collapsed .header-config {
            opacity: 0;
            transform: scaleY(0);
            height: 0;
            margin: 0;
            overflow: hidden;
        }

        .system-prompt {
            width: 100%;
            background: transparent;
            border: none;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            padding: 1rem 0;
            color: #e8e8e8;
            font-size: 1rem;
            font-weight: 300;
            resize: none;
            min-height: 60px;
            font-family: inherit;
            transition: all 0.3s ease;
            opacity: 0;
            animation: fadeInUp 0.8s ease 0.2s forwards;
        }

        .system-prompt:focus {
            outline: none;
            border-bottom-color: rgba(255,255,255,0.3);
            color: #ffffff;
        }

        .system-prompt::placeholder {
            color: rgba(255,255,255,0.4);
            font-weight: 300;
        }

        .api-key-input {
            width: 100%;
            background: transparent;
            border: none;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            padding: 1rem 0;
            color: #e8e8e8;
            font-size: 1rem;
            font-weight: 300;
            margin-top: 1.5rem;
            font-family: inherit;
            transition: all 0.3s ease;
            opacity: 0;
            animation: fadeInUp 0.8s ease 0.4s forwards;
        }

        .api-key-input:focus {
            outline: none;
            border-bottom-color: rgba(255,255,255,0.3);
            color: #ffffff;
        }

        .api-key-input::placeholder {
            color: rgba(255,255,255,0.4);
            font-weight: 300;
        }

        .thinking-toggle {
            display: flex;
            align-items: center;
            gap: 1rem;
            font-size: 0.9rem;
            font-weight: 300;
            margin-top: 2rem;
            opacity: 0;
            animation: fadeInUp 0.8s ease 0.6s forwards;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .thinking-toggle:hover {
            color: #ffffff;
        }

        .thinking-toggle input[type="checkbox"] {
            width: 18px;
            height: 18px;
            background: transparent;
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 2px;
            cursor: pointer;
            transition: all 0.3s ease;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            position: relative;
        }

        .thinking-toggle input[type="checkbox"]:checked {
            background: rgba(255,255,255,0.1);
            border-color: rgba(255,255,255,0.4);
        }

        .thinking-toggle input[type="checkbox"]:checked::after {
            content: '✓';
            position: absolute;
            top: -2px;
            left: 2px;
            color: rgba(255,255,255,0.8);
            font-size: 12px;
            font-weight: 400;
        }

        .chat-container {
            flex: 1;
            overflow-y: auto;
            padding: 1rem 3rem 1rem 3rem;
            display: flex;
            flex-direction: column;
            gap: 2rem;
        }

        .message {
            max-width: 100%;
            transition: all 0.5s ease;
            transform: translateY(20px);
            opacity: 0;
            animation: slideInFade 0.6s ease forwards;
            position: relative;
        }

        .message.user {
            text-align: right;
            margin-left: 20%;
        }

        .message.assistant, .message.thinking {
            text-align: left;
            margin-right: 20%;
        }

        .message.thinking {
            opacity: 0.7;
        }

        /* Branch from indicator */
        .message.branch-selected {
            position: relative;
        }

        .message.branch-selected::before {
            content: '↳ continue from here';
            position: absolute;
            top: -1.5rem;
            right: 0;
            font-size: 0.7rem;
            color: rgba(116, 59, 237, 0.8);
            font-weight: 400;
            letter-spacing: 0.05em;
            text-transform: uppercase;
            opacity: 0;
            animation: fadeInUp 0.3s ease forwards;
        }

        .branch-indicator {
            position: absolute;
            left: -2rem;
            top: 50%;
            transform: translateY(-50%);
            width: 12px;
            height: 12px;
            border: 2px solid rgba(116, 59, 237, 0.6);
            border-radius: 50%;
            background: rgba(116, 59, 237, 0.1);
            opacity: 0;
            transition: all 0.3s ease;
        }

        .message.branch-selected .branch-indicator {
            opacity: 1;
            background: rgba(116, 59, 237, 0.3);
            border-color: rgba(116, 59, 237, 0.8);
        }

        .message-label {
            font-size: 0.8rem;
            font-weight: 400;
            margin-bottom: 0.8rem;
            opacity: 0.6;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            transition: all 0.3s ease;
        }

        .message.user .message-label {
            color: rgba(255,255,255,0.5);
        }

        .message.assistant .message-label {
            color: rgba(255,255,255,0.5);
        }

        .message.thinking .message-label {
            color: rgba(255,255,255,0.4);
        }

        .message-content {
            font-size: 1rem;
            font-weight: 300;
            line-height: 1.7;
            transition: all 0.3s ease;
        }

        .message.thinking .message-content {
            font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Fira Code', monospace;
            font-size: 0.9rem;
            opacity: 0.8;
            white-space: pre-wrap;
            line-height: 1.6;
        }

        /* Real-time thinking animation styles */
        .thinking-token {
            opacity: 0;
            transform: translateY(8px);
            animation: thinkingFadeIn 0.6s ease forwards;
            display: inline;
        }

        .thinking-cursor {
            display: inline-block;
            width: 2px;
            height: 1.2em;
            background: rgba(255,255,255,0.5);
            margin-left: 2px;
            animation: pulse 1s ease-in-out infinite;
            vertical-align: text-bottom;
        }

        @keyframes thinkingFadeIn {
            to {
                opacity: 0.8;
                transform: translateY(0);
            }
        }

        @keyframes pulse {
            0%, 50% { opacity: 0.5; }
            25%, 75% { opacity: 0.8; }
        }

        .thinking-complete .thinking-cursor {
            display: none;
        }

        .message-content h1, .message-content h2, .message-content h3 {
            margin: 2rem 0 1rem 0;
            color: #ffffff;
            font-weight: 300;
            letter-spacing: -0.01em;
        }

        .message-content h1 { font-size: 1.8rem; }
        .message-content h2 { font-size: 1.4rem; }
        .message-content h3 { font-size: 1.2rem; }

        .message-content p {
            margin: 1rem 0;
        }

        .message-content pre {
            background: rgba(255,255,255,0.02);
            border-radius: 8px;
            padding: 1.5rem;
            overflow-x: auto;
            margin: 2rem 0;
            font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Fira Code', monospace;
            border: 1px solid rgba(255,255,255,0.05);
        }

        .message-content code {
            background: rgba(255,255,255,0.08);
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Fira Code', monospace;
            font-size: 0.9em;
        }

        .message-content pre code {
            background: none;
            padding: 0;
        }

        .input-area {
            padding: 1.5rem 3rem 2rem 3rem;
            background: linear-gradient(0deg, rgba(26,26,26,0.95) 0%, rgba(26,26,26,0) 100%);
            backdrop-filter: blur(20px);
            display: flex;
            gap: 2rem;
            align-items: flex-end;
            position: relative;
        }

        /* Branch context indicator */
        .branch-context {
            position: absolute;
            top: 0.5rem;
            left: 3rem;
            right: 3rem;
            text-align: center;
            font-size: 0.8rem;
            color: rgba(116, 59, 237, 0.8);
            font-weight: 300;
            opacity: 0;
            transform: translateY(-10px);
            transition: all 0.3s ease;
            pointer-events: none;
        }

        .branch-context.active {
            opacity: 1;
            transform: translateY(0);
        }

        .message-input {
            flex: 1;
            background: transparent;
            border: none;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            padding: 1rem 0;
            color: #e8e8e8;
            resize: none;
            min-height: 24px;
            max-height: 120px;
            font-size: 1rem;
            font-weight: 300;
            font-family: inherit;
            transition: all 0.3s ease;
        }

        .message-input:focus {
            outline: none;
            border-bottom-color: rgba(255,255,255,0.3);
            color: #ffffff;
        }

        .message-input::placeholder {
            color: rgba(255,255,255,0.4);
            font-weight: 300;
        }

        .btn {
            background: none;
            color: rgba(255,255,255,0.6);
            border: none;
            padding: 1rem 0;
            cursor: pointer;
            font-weight: 300;
            font-size: 1rem;
            font-family: inherit;
            transition: all 0.3s ease;
            position: relative;
            min-width: 80px;
        }

        .btn:hover {
            color: #ffffff;
            transform: translateY(-1px);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn:disabled {
            color: rgba(255,255,255,0.2);
            cursor: not-allowed;
            transform: none;
        }

        .btn::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            width: 0;
            height: 1px;
            background: rgba(255,255,255,0.3);
            transition: width 0.3s ease;
        }

        .btn:hover::after {
            width: 100%;
        }

        .controls {
            display: flex;
            gap: 2rem;
            align-items: flex-end;
        }

        .error {
            color: #ff6b6b !important;
        }

        .error .message-label {
            color: rgba(255, 107, 107, 0.6) !important;
        }

        /* Confirmation Modal */
        .confirmation-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.8);
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
            z-index: 1000;
        }

        .confirmation-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .confirmation-modal {
            background: linear-gradient(180deg, #1a1a1a 0%, #0f0f0f 100%);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 12px;
            padding: 3rem;
            max-width: 400px;
            text-align: center;
            transform: translateY(20px) scale(0.9);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .confirmation-overlay.active .confirmation-modal {
            transform: translateY(0) scale(1);
        }

        .confirmation-modal h3 {
            font-size: 1.5rem;
            font-weight: 300;
            color: #ffffff;
            margin-bottom: 1rem;
            letter-spacing: -0.01em;
        }

        .confirmation-modal p {
            font-size: 1rem;
            font-weight: 300;
            color: rgba(255,255,255,0.7);
            margin-bottom: 2rem;
            line-height: 1.6;
        }

        .confirmation-actions {
            display: flex;
            gap: 2rem;
            justify-content: center;
        }

        .confirmation-btn {
            background: none;
            border: none;
            padding: 0.75rem 1.5rem;
            font-size: 1rem;
            font-weight: 300;
            font-family: inherit;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }

        .confirmation-btn.cancel {
            color: rgba(255,255,255,0.6);
        }

        .confirmation-btn.confirm {
            color: #ff6b6b;
        }

        .confirmation-btn:hover {
            transform: translateY(-1px);
        }

        .confirmation-btn::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            width: 0;
            height: 1px;
            background: currentColor;
            transition: width 0.3s ease;
        }

        .confirmation-btn:hover::after {
            width: 100%;
        }

        /* Conversation path indicator */
        .path-indicator {
            position: absolute;
            top: 1rem;
            right: 3rem;
            font-size: 0.8rem;
            color: rgba(255,255,255,0.4);
            font-weight: 300;
            opacity: 0;
            transition: all 0.3s ease;
            pointer-events: none;
        }

        .header:not(.collapsed) .path-indicator {
            opacity: 1;
        }

        .path-switcher {
            margin-top: 0.5rem;
            display: flex;
            gap: 1rem;
            align-items: center;
            opacity: 0;
            transition: all 0.3s ease;
        }

        .path-switcher.visible {
            opacity: 1;
        }

        .path-btn {
            background: none;
            border: none;
            color: rgba(255,255,255,0.5);
            font-size: 0.8rem;
            font-weight: 300;
            font-family: inherit;
            cursor: pointer;
            padding: 0.25rem 0.5rem;
            transition: all 0.3s ease;
            position: relative;
        }

        .path-btn.active {
            color: rgba(255,255,255,0.8);
        }

        .path-btn:hover {
            color: rgba(255,255,255,0.9);
            transform: translateY(-1px);
        }

        .path-btn::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            width: 0;
            height: 1px;
            background: currentColor;
            transition: width 0.3s ease;
        }

        .path-btn:hover::after,
        .path-btn.active::after {
            width: 100%;
        }

        /* Response variants and redo functionality */
        .message-actions {
            opacity: 0;
            transition: all 0.3s ease;
            margin-top: 0.5rem;
            display: flex;
            gap: 1rem;
            justify-content: flex-end;
            align-items: center;
        }

        .message.assistant:hover .message-actions {
            opacity: 1;
        }

        .message-btn {
            background: none;
            border: none;
            color: rgba(255,255,255,0.4);
            font-size: 0.8rem;
            font-weight: 300;
            font-family: inherit;
            cursor: pointer;
            padding: 0.25rem 0.5rem;
            transition: all 0.3s ease;
            position: relative;
        }

        .message-btn:hover {
            color: rgba(255,255,255,0.8);
            transform: translateY(-1px);
        }

        .message-btn::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            width: 0;
            height: 1px;
            background: currentColor;
            transition: width 0.3s ease;
        }

        .message-btn:hover::after {
            width: 100%;
        }

        .branch-indicator {
            font-size: 0.8rem;
            color: rgba(255,255,255,0.3);
            font-weight: 300;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .branch-nav {
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .branch-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: rgba(255,255,255,0.2);
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .branch-dot.active {
            background: rgba(255,255,255,0.6);
            transform: scale(1.2);
        }

        /* ======= SIMPLIFIED LAYERED VARIANTS SYSTEM - MAX 3 VARIANTS ======= */
        
        /* Container for layered responses */
        .variants-container {
            position: relative;
            min-height: 200px; /* Ensure space for layered effect */
            margin: 1rem 0;
        }

        /* Individual variant layers */
        .response-variant {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            background: none;
            border: none;
            border-radius: 8px;
            padding: 1.5rem;
            cursor: pointer;
            transition: all 0.8s cubic-bezier(0.4, 0, 0.2, 1);
            transform-origin: center;
            backface-visibility: hidden;
            will-change: transform, opacity, filter;
        }

        /* Active variant (front layer) */
        .response-variant.active {
            opacity: 1;
            transform: translateX(0) translateY(0) scale(1);
            z-index: 10;
            filter: blur(0px);
        }

        /* First inactive variant - blurred, translucent, offset but selectable */
        .response-variant.variant-1 {
            opacity: 0.3;
            transform: translateX(120px) translateY(60px) scale(0.8);
            z-index: 8;
            filter: blur(2px);
            pointer-events: all;
            cursor: pointer;
        }

        .response-variant.variant-1:hover {
            opacity: 0.5;
            transform: translateX(110px) translateY(50px) scale(0.82);
            filter: blur(1px);
        }

        /* Second inactive variant - smaller, more faded but still selectable */
        .response-variant.variant-2 {
            opacity: 0.15;
            transform: translateX(160px) translateY(90px) scale(0.65);
            z-index: 6;
            filter: blur(3px);
            pointer-events: all;
            cursor: pointer;
        }

        .response-variant.variant-2:hover {
            opacity: 0.35;
            transform: translateX(150px) translateY(80px) scale(0.68);
            filter: blur(2px);
        }

        /* Branch selected variant gets subtle highlighting only when active */
        .response-variant.branch-selected.active {
            box-shadow: 0 0 20px rgba(116, 59, 237, 0.1);
        }

        /* Enhanced message actions for variants */
        .message.has-variants .message-actions {
            position: relative;
            z-index: 15;
            margin-top: 2rem; /* Give space for the layered variants */
        }

        /* Smooth transitions for variant switching */
        .variants-container.switching .response-variant {
            transition: all 0.8s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* ======= END LAYERED VARIANTS SYSTEM ======= */

        /* Custom scrollbar */
        ::-webkit-scrollbar {
            width: 2px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(255,255,255,0.05);
            border-radius: 1px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(255,255,255,0.1);
        }

        /* Hide scrollbars in Firefox */
        * {
            scrollbar-width: thin;
            scrollbar-color: rgba(255,255,255,0.05) transparent;
        }

        /* Animations */
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes slideInFade {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .header, .chat-container, .input-area {
                padding-left: 1.5rem;
                padding-right: 1.5rem;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .message.user {
                margin-left: 10%;
            }
            
            .message.assistant, .message.thinking {
                margin-right: 10%;
            }

            /* Adjust layered effect for mobile - maintain dramatic offset */
            .response-variant:not(.active) {
                transform: translateX(100px) translateY(70px) scale(0.65);
            }

            .response-variant:not(.active):nth-child(3) {
                transform: translateX(120px) translateY(100px) scale(0.6);
            }
        }
    </style>
</head>
<body>
    <div class="header" id="header">
        <h1 id="headerToggle">harpoon</h1>
        <div class="path-indicator" id="pathIndicator">conversation thread: main</div>
        <div class="header-config">
            <textarea class="system-prompt" placeholder="system prompt">You are a helpful assistant.</textarea>
            <input type="password" class="api-key-input" placeholder="api key" id="apiKey">
            <label class="thinking-toggle">
                <input type="checkbox" id="showThinking" checked>
                <span>show thinking</span>
            </label>
            <div class="path-switcher" id="pathSwitcher">
                <span style="color: rgba(255,255,255,0.4); font-size: 0.8rem;">threads:</span>
                <button class="path-btn active" data-path="main">main</button>
            </div>
        </div>
    </div>

    <div class="chat-container" id="chatContainer">
        <!-- Messages will be added here -->
    </div>

    <div class="input-area">
        <div class="branch-context" id="branchContext">
            responding from selected variant
        </div>
        <textarea class="message-input" id="messageInput" placeholder="message" rows="1"></textarea>
        <div class="controls">
            <input type="file" id="importFile" accept=".json" style="display: none;" onchange="importConversation(event)">
            <button class="btn" onclick="document.getElementById('importFile').click()">import</button>
            <button class="btn" id="sendBtn">send</button>
            <button class="btn" id="refreshBtn">refresh</button>
            <button class="btn" id="exportBtn">export</button>
        </div>
    </div>

    <!-- Confirmation Modal -->
    <div class="confirmation-overlay" id="confirmationOverlay">
        <div class="confirmation-modal">
            <h3>Clear conversation?</h3>
            <p>This will remove all messages from your current chat session. This action cannot be undone.</p>
            <div class="confirmation-actions">
                <button class="confirmation-btn cancel" id="cancelBtn">cancel</button>
                <button class="confirmation-btn confirm" id="confirmBtn">clear</button>
            </div>
        </div>
    </div>

    <script>
        // Enhanced chat state management for conversation trees with branch selection
        let conversationTree = {
            messages: [], // Linear message history for current path
            branches: new Map(), // messageId -> [response variants]
            paths: new Map([['main', []]]), // pathId -> messages array
            currentPath: 'main', // Current active path
            messageIdCounter: 0,
            pathCounter: 0,
            branchSelection: null // { messageId, variantIndex } - selected point for branching
        };

        // Make import function available globally for onclick handler
        window.importConversation = importConversation;
        let isLoading = false;

        // DOM elements
        const chatContainer = document.getElementById('chatContainer');
        const messageInput = document.getElementById('messageInput');
        const sendBtn = document.getElementById('sendBtn');
        const refreshBtn = document.getElementById('refreshBtn');
        const exportBtn = document.getElementById('exportBtn');
        const apiKeyInput = document.getElementById('apiKey');
        const systemPromptInput = document.querySelector('.system-prompt');
        const showThinkingCheckbox = document.getElementById('showThinking');
        const header = document.getElementById('header');
        const headerToggle = document.getElementById('headerToggle');
        const confirmationOverlay = document.getElementById('confirmationOverlay');
        const cancelBtn = document.getElementById('cancelBtn');
        const confirmBtn = document.getElementById('confirmBtn');
        const pathIndicator = document.getElementById('pathIndicator');
        const pathSwitcher = document.getElementById('pathSwitcher');
        const branchContext = document.getElementById('branchContext');

        // Core path management functions
        function getCurrentPath() {
            return conversationTree.paths.get(conversationTree.currentPath) || [];
        }

        function updateCurrentPath(messages) {
            conversationTree.paths.set(conversationTree.currentPath, messages);
            updatePathIndicator();
        }

        function updatePathIndicator() {
            pathIndicator.textContent = `conversation thread: ${conversationTree.currentPath}`;
        }

        function switchToPath(pathId) {
            conversationTree.currentPath = pathId;
            conversationTree.messages = getCurrentPath();
            conversationTree.branchSelection = null; // Clear branch selection when switching paths
            updatePathIndicator();
            rebuildChatFromTree();
            updatePathSwitcher();
            updateBranchContext();
            saveConversationTree();
        }

        function createNewPathFromBranch(messageId, variantIndex) {
            // Find the message in the current conversation
            const currentPath = getCurrentPath();
            const messageIndex = currentPath.findIndex(msg => msg.id === messageId);
            if (messageIndex === -1) return null;

            // Get the conversation up to that point
            const conversationUpToBranch = currentPath.slice(0, messageIndex);
            
            // Get the selected variant
            const variants = conversationTree.branches.get(messageId);
            if (!variants || !variants[variantIndex]) return null;
            
            const selectedVariant = variants[variantIndex];
            
            // Create new path ID
            const newPathId = `branch_${++conversationTree.pathCounter}`;
            
            // Create the new path with conversation up to and including the selected variant
            const newPath = [...conversationUpToBranch, selectedVariant];
            conversationTree.paths.set(newPathId, newPath);
            
            return newPathId;
        }

        function updatePathSwitcher() {
            const pathBtns = pathSwitcher.querySelectorAll('.path-btn');
            pathBtns.forEach(btn => {
                btn.classList.toggle('active', btn.dataset.path === conversationTree.currentPath);
            });
            
            // Show switcher if there are multiple paths
            if (conversationTree.paths.size > 1) {
                pathSwitcher.classList.add('visible');
                
                // Add any new path buttons
                Array.from(conversationTree.paths.keys()).forEach(pathId => {
                    if (!pathSwitcher.querySelector(`[data-path="${pathId}"]`)) {
                        const btn = document.createElement('button');
                        btn.className = 'path-btn';
                        btn.dataset.path = pathId;
                        btn.textContent = pathId;
                        btn.onclick = () => switchToPath(pathId);
                        pathSwitcher.appendChild(btn);
                    }
                });
            }
        }

        // Branch selection management
        function setBranchSelection(messageId, variantIndex) {
            // Clear previous selection
            clearBranchSelection();
            
            // Set new selection
            conversationTree.branchSelection = { messageId, variantIndex };
            
            // Update UI
            updateBranchSelectionUI();
            updateBranchContext();
            saveConversationTree();
        }

        function clearBranchSelection() {
            conversationTree.branchSelection = null;
            
            // Clear UI indicators
            document.querySelectorAll('.message.branch-selected, .response-variant.branch-selected').forEach(el => {
                el.classList.remove('branch-selected');
            });
            
            updateBranchContext();
        }

        function updateBranchSelectionUI() {
            if (!conversationTree.branchSelection) return;
            
            const { messageId, variantIndex } = conversationTree.branchSelection;
            const messageEl = document.querySelector(`[data-message-id="${messageId}"]`);
            
            if (messageEl) {
                messageEl.classList.add('branch-selected');
                
                // Add branch indicator if it doesn't exist
                if (!messageEl.querySelector('.branch-indicator')) {
                    const indicator = document.createElement('div');
                    indicator.className = 'branch-indicator';
                    messageEl.appendChild(indicator);
                }
                
                // Highlight the specific variant if there are multiple
                const variants = messageEl.querySelectorAll('.response-variant');
                if (variants.length > 0 && variants[variantIndex]) {
                    variants[variantIndex].classList.add('branch-selected');
                }
            }
        }

        function updateBranchContext() {
            if (conversationTree.branchSelection) {
                branchContext.classList.add('active');
            } else {
                branchContext.classList.remove('active');
            }
        }

        // Auto-resize textarea with smooth transitions
        messageInput.addEventListener('input', function() {
            this.style.height = 'auto';
            this.style.height = this.scrollHeight + 'px';
        });

        // Send message on Enter (Shift+Enter for new line)
        messageInput.addEventListener('keydown', function(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });

        // Button event handlers
        sendBtn.addEventListener('click', sendMessage);
        refreshBtn.addEventListener('click', showRefreshConfirmation);
        exportBtn.addEventListener('click', exportChat);

        // Header collapse functionality
        headerToggle.addEventListener('click', toggleHeader);

        // Confirmation modal handlers
        cancelBtn.addEventListener('click', hideRefreshConfirmation);
        confirmBtn.addEventListener('click', confirmRefresh);
        confirmationOverlay.addEventListener('click', function(e) {
            if (e.target === confirmationOverlay) {
                hideRefreshConfirmation();
            }
        });

        // Header collapse state management
        function toggleHeader() {
            header.classList.toggle('collapsed');
            // Save the collapsed state to localStorage for persistence
            const isCollapsed = header.classList.contains('collapsed');
            localStorage.setItem('headerCollapsed', isCollapsed);
        }

        // Restore header state on page load
        function restoreHeaderState() {
            const isCollapsed = localStorage.getItem('headerCollapsed') === 'true';
            if (isCollapsed) {
                header.classList.add('collapsed');
            }
        }

        // Refresh confirmation functions
        function showRefreshConfirmation() {
            confirmationOverlay.classList.add('active');
        }

        function hideRefreshConfirmation() {
            confirmationOverlay.classList.remove('active');
        }

        function confirmRefresh() {
            // Clear all conversation data and reset to initial state
            conversationTree = {
                messages: [],
                branches: new Map(),
                paths: new Map([['main', []]]),
                currentPath: 'main',
                messageIdCounter: 0,
                pathCounter: 0,
                branchSelection: null
            };
            chatContainer.innerHTML = '';
            hideRefreshConfirmation();
            
            // Reset UI indicators
            updatePathIndicator();
            updateBranchContext();
            pathSwitcher.classList.remove('visible');
            pathSwitcher.innerHTML = `
                <span style="color: rgba(255,255,255,0.4); font-size: 0.8rem;">threads:</span>
                <button class="path-btn active" data-path="main">main</button>
            `;
            
            // Clear persisted state
            localStorage.removeItem('deepseekConversationTree');
            
            // Provide subtle feedback
            refreshBtn.style.transform = 'translateY(-2px)';
            setTimeout(() => {
                refreshBtn.style.transform = '';
                messageInput.focus();
            }, 150);
        }

        // Enhanced persistence functions for branch-aware conversations
        function saveConversationTree() {
            try {
                const serializable = {
                    messages: conversationTree.messages,
                    branches: Array.from(conversationTree.branches.entries()),
                    paths: Array.from(conversationTree.paths.entries()),
                    currentPath: conversationTree.currentPath,
                    messageIdCounter: conversationTree.messageIdCounter,
                    pathCounter: conversationTree.pathCounter,
                    branchSelection: conversationTree.branchSelection,
                    systemPrompt: systemPromptInput.value,
                    timestamp: new Date().toISOString()
                };
                localStorage.setItem('deepseekConversationTree', JSON.stringify(serializable));
            } catch (error) {
                console.error('Failed to save conversation:', error);
            }
        }

        function loadConversationTree() {
            try {
                const saved = localStorage.getItem('deepseekConversationTree');
                if (!saved) return false;
                
                const data = JSON.parse(saved);
                
                // Restore conversation tree with branch selection
                conversationTree = {
                    messages: data.messages || [],
                    branches: new Map(data.branches || []),
                    paths: new Map(data.paths || [['main', data.messages || []]]),
                    currentPath: data.currentPath || 'main',
                    messageIdCounter: data.messageIdCounter || 0,
                    pathCounter: data.pathCounter || 0,
                    branchSelection: data.branchSelection || null
                };
                
                // Ensure current path exists
                if (!conversationTree.paths.has(conversationTree.currentPath)) {
                    conversationTree.currentPath = 'main';
                    if (!conversationTree.paths.has('main')) {
                        conversationTree.paths.set('main', []);
                    }
                }
                
                // Update messages to match current path
                conversationTree.messages = getCurrentPath();
                
                // Restore system prompt
                if (data.systemPrompt) {
                    systemPromptInput.value = data.systemPrompt;
                }
                
                // Rebuild UI
                rebuildChatFromTree();
                updatePathIndicator();
                updatePathSwitcher();
                updateBranchContext();
                
                return true;
            } catch (error) {
                console.error('Failed to load conversation:', error);
                return false;
            }
        }

        function rebuildChatFromTree() {
            chatContainer.innerHTML = '';
            
            // Use current path messages
            const currentMessages = getCurrentPath();
            
            currentMessages.forEach(msg => {
                if (msg.role === 'user') {
                    addMessage(msg.content, 'user', false, false, msg.id);
                } else if (msg.role === 'assistant') {
                    // Add thinking if it exists
                    if (msg.thinking && showThinkingCheckbox.checked) {
                        addMessage(msg.thinking, 'assistant', true, false, `${msg.id}_thinking`);
                    }
                    
                    // Check if this message has variants
                    const variants = conversationTree.branches.get(msg.id);
                    if (variants && variants.length > 1) {
                        // Find current variant index
                        const currentVariantIndex = variants.findIndex(v => v.content === msg.content);
                        addMessage(msg.content, 'assistant', false, false, msg.id, variants);
                        
                        // Set the correct variant as active
                        setTimeout(() => {
                            if (currentVariantIndex >= 0) {
                                const messageEl = document.querySelector(`[data-message-id="${msg.id}"]`);
                                if (messageEl) {
                                    const variantEls = messageEl.querySelectorAll('.response-variant');
                                    variantEls.forEach((el, idx) => {
                                        el.classList.toggle('active', idx === currentVariantIndex);
                                    });
                                }
                            }
                        }, 100);
                    } else {
                        // Add single response
                        addMessage(msg.content, 'assistant', false, false, msg.id);
                    }
                }
            });
            
            // Restore branch selection UI
            setTimeout(() => {
                updateBranchSelectionUI();
            }, 200);
        }

        // Enhanced function to add messages with layered variants and branch selection support
        function addMessage(content, role, isThinking = false, isStreaming = false, messageId = null, variants = null) {
            const msgId = messageId || `msg_${++conversationTree.messageIdCounter}`;
            
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${role}${isThinking ? ' thinking' : ''}`;
            messageDiv.dataset.messageId = msgId;
            
            const labelDiv = document.createElement('div');
            labelDiv.className = 'message-label';
            labelDiv.textContent = isThinking ? 'thinking' : (role === 'user' ? 'you' : 'assistant');
            
            const contentDiv = document.createElement('div');
            contentDiv.className = 'message-content';
            
            if (isStreaming) {
                contentDiv.innerHTML = '';
                if (isThinking) {
                    const cursor = document.createElement('span');
                    cursor.className = 'thinking-cursor';
                    contentDiv.appendChild(cursor);
                }
            } else {
                if (role === 'assistant' && !isThinking) {
                    // For assistant messages, handle variants with layered visual system
                    if (variants && variants.length > 1) {
                        contentDiv.innerHTML = createLayeredVariantsHTML(variants, msgId);
                        messageDiv.classList.add('has-variants');
                    } else {
                        contentDiv.innerHTML = marked.parse(content);
                    }
                } else {
                    contentDiv.textContent = content;
                }
            }
            
            messageDiv.appendChild(labelDiv);
            messageDiv.appendChild(contentDiv);
            
            // Add action buttons for assistant messages
            if (role === 'assistant' && !isThinking) {
                const actionsDiv = document.createElement('div');
                actionsDiv.className = 'message-actions';
                
                const redoBtn = document.createElement('button');
                redoBtn.className = 'message-btn redo-btn';
                redoBtn.textContent = 'redo';
                redoBtn.onclick = () => redoResponse(msgId);
                
                actionsDiv.appendChild(redoBtn);
                messageDiv.appendChild(actionsDiv);
            }
            
            chatContainer.appendChild(messageDiv);
            
            // Smooth scroll to bottom
            setTimeout(() => {
                chatContainer.scrollTo({
                    top: chatContainer.scrollHeight,
                    behavior: 'smooth'
                });
            }, 100);
            
            return { element: messageDiv, id: msgId };
        }

        // Enhanced function to create layered variants HTML - pure ghost interaction, MAX 3 VARIANTS
        function createLayeredVariantsHTML(variants, messageId) {
            const containerDiv = document.createElement('div');
            containerDiv.className = 'variants-container';
            
            // Only handle up to 3 variants (original + 2 redos)
            const limitedVariants = variants.slice(0, 3);
            
            limitedVariants.forEach((variant, index) => {
                const variantDiv = document.createElement('div');
                // Apply proper variant classes for layered positioning
                let variantClass = 'response-variant';
                if (index === 0) {
                    variantClass += ' active';
                } else if (index === 1) {
                    variantClass += ' variant-1';
                } else if (index === 2) {
                    variantClass += ' variant-2';
                }
                
                variantDiv.className = variantClass;
                variantDiv.dataset.variantIndex = index;
                variantDiv.onclick = () => selectVariantForBranch(messageId, index);
                
                // Add variant content - NO BADGES, PURE CONTENT
                const contentDiv = document.createElement('div');
                contentDiv.innerHTML = marked.parse(variant.content);
                variantDiv.appendChild(contentDiv);
                
                containerDiv.appendChild(variantDiv);
            });
            
            return containerDiv.outerHTML;
        }

        // Function to select a variant and update conversation state
        function selectVariantForBranch(messageId, variantIndex) {
            const messageEl = document.querySelector(`[data-message-id="${messageId}"]`);
            if (!messageEl) return;
            
            const variantsContainer = messageEl.querySelector('.variants-container');
            if (!variantsContainer) return;
            
            // Get the variants for this message
            const variants = conversationTree.branches.get(messageId);
            if (!variants || !variants[variantIndex]) return;
            
            // Add switching class for enhanced transitions
            variantsContainer.classList.add('switching');
            
            // Update the conversation tree to use the selected variant
            const currentPath = getCurrentPath();
            const messageIndex = currentPath.findIndex(msg => msg.id === messageId);
            
            if (messageIndex !== -1) {
                // Replace the message in the current path with the selected variant
                const updatedPath = [...currentPath];
                updatedPath[messageIndex] = variants[variantIndex];
                updateCurrentPath(updatedPath);
                conversationTree.messages = updatedPath;
            }
            
            // Set this variant as the branch selection point
            setBranchSelection(messageId, variantIndex);
            
            // Update visual layered state for variants with smooth transitions
            const variantElements = variantsContainer.querySelectorAll('.response-variant');
            variantElements.forEach((variant, index) => {
                // Remove active class from all
                variant.classList.remove('active');
                
                // Add active class to selected variant after a brief delay for smooth transition
                if (index === variantIndex) {
                    setTimeout(() => {
                        variant.classList.add('active');
                    }, 50);
                }
            });
            
            // Remove switching class after transition
            setTimeout(() => {
                variantsContainer.classList.remove('switching');
                saveConversationTree(); // Save the updated state
            }, 800);
            
            console.log(`Switched to variant ${variantIndex + 1} of message ${messageId}`);
        }

        // Enhanced function to send a message with branch-aware logic
        async function sendMessage() {
            const message = messageInput.value.trim();
            const apiKey = apiKeyInput.value.trim();
            
            if (!message || !apiKey || isLoading) return;
            
            let targetPath = conversationTree.currentPath;
            let conversationHistory;
            
            // Check if we're branching from a selected variant
            if (conversationTree.branchSelection) {
                const { messageId, variantIndex } = conversationTree.branchSelection;
                
                // Create new branch path
                const newPathId = createNewPathFromBranch(messageId, variantIndex);
                if (newPathId) {
                    // Switch to new branch path
                    targetPath = newPathId;
                    switchToPath(targetPath);
                    conversationHistory = getCurrentPath();
                } else {
                    // Fallback to current path
                    conversationHistory = getCurrentPath();
                }
                
                // Clear branch selection after creating the branch
                clearBranchSelection();
            } else {
                // Normal continuation from current path
                conversationHistory = getCurrentPath();
            }
            
            // Add user message to the target path
            const userMsg = addMessage(message, 'user');
            const updatedHistory = [...conversationHistory, {
                id: userMsg.id,
                role: 'user',
                content: message
            }];
            
            // Update the target path
            conversationTree.paths.set(targetPath, updatedHistory);
            conversationTree.messages = updatedHistory;
            
            // Clear input with fade effect
            messageInput.style.opacity = '0.5';
            setTimeout(() => {
                messageInput.value = '';
                messageInput.style.height = 'auto';
                messageInput.style.opacity = '1';
            }, 150);
            
            // Generate AI response
            try {
                await generateAIResponse();
                
                // Update the path with the new AI response
                const finalPath = getCurrentPath();
                conversationTree.paths.set(targetPath, finalPath);
                
                // Update UI
                updatePathSwitcher();
                saveConversationTree();
                
            } catch (error) {
                console.error('Error:', error);
                const errorMsg = addMessage(`Error: ${error.message}`, 'assistant');
                errorMsg.element.classList.add('error');
            }
        }

        // Enhanced redo function with TWO REDO LIMIT for branch-aware conversations
        async function redoResponse(messageId) {
            if (isLoading) return;
            
            // Find the message in the current path
            const currentPath = getCurrentPath();
            const messageIndex = currentPath.findIndex(msg => msg.id === messageId);
            if (messageIndex === -1) return;

            // Check if we already have 3 variants (original + 2 redos) - ENFORCE LIMIT
            const existingVariants = conversationTree.branches.get(messageId) || [currentPath[messageIndex]];
            if (existingVariants.length >= 3) {
                // Visual feedback that limit is reached
                const messageEl = document.querySelector(`[data-message-id="${messageId}"]`);
                const redoBtn = messageEl?.querySelector('.redo-btn');
                if (redoBtn) {
                    const originalText = redoBtn.textContent;
                    redoBtn.textContent = 'limit reached';
                    redoBtn.style.color = 'rgba(255, 107, 107, 0.6)';
                    setTimeout(() => {
                        redoBtn.textContent = originalText;
                        redoBtn.style.color = '';
                    }, 2000);
                }
                return;
            }
            
            // Get the conversation state up to (but not including) this AI response
            const conversationUpToRedo = currentPath.slice(0, messageIndex);
            
            try {
                const apiKey = apiKeyInput.value.trim();
                if (!apiKey) throw new Error('API key required');
                
                const systemPrompt = systemPromptInput.value.trim();
                const requestMessages = [];
                
                if (systemPrompt) {
                    requestMessages.push({ role: 'system', content: systemPrompt });
                }
                
                requestMessages.push(...conversationUpToRedo.map(msg => ({
                    role: msg.role,
                    content: msg.content
                })));
                
                // Set loading state on the redo button
                const messageEl = document.querySelector(`[data-message-id="${messageId}"]`);
                const redoBtn = messageEl?.querySelector('.redo-btn');
                if (redoBtn) {
                    redoBtn.textContent = 'generating...';
                    redoBtn.disabled = true;
                }
                
                // Create temporary containers for the new response
                let tempThinkingContainer = null;
                let newThinkingContent = '';
                let newResponseContent = '';
                
                // Create temporary thinking display if enabled
                if (showThinkingCheckbox.checked) {
                    const tempThinkingDiv = document.createElement('div');
                    tempThinkingDiv.className = 'message assistant thinking';
                    tempThinkingDiv.innerHTML = `
                        <div class="message-label">thinking (generating variant)</div>
                        <div class="message-content"><span class="thinking-cursor"></span></div>
                    `;
                    messageEl.parentNode.insertBefore(tempThinkingDiv, messageEl.nextSibling);
                    tempThinkingContainer = tempThinkingDiv.querySelector('.message-content');
                }
                
                // Make streaming API call
                const response = await fetch('https://api.deepseek.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: 'deepseek-reasoner',
                        messages: requestMessages,
                        temperature: 0.6,
                        stream: true
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`API Error: ${response.status} ${response.statusText}`);
                }
                
                // Process streaming response
                const { thinkingText, responseText } = await processStreamingResponse(
                    response, 
                    tempThinkingContainer, 
                    null
                );
                
                newThinkingContent = thinkingText;
                newResponseContent = responseText;
                
                // Remove temporary thinking display
                if (tempThinkingContainer) {
                    tempThinkingContainer.closest('.message').remove();
                }
                
                // Create new variant object
                const newVariant = {
                    id: messageId,
                    role: 'assistant',
                    content: newResponseContent,
                    thinking: newThinkingContent
                };
                
                // Get existing variants or create new array with original
                const originalMessage = currentPath[messageIndex];
                let variants = conversationTree.branches.get(messageId) || [originalMessage];
                
                // Add new variant
                variants.push(newVariant);
                conversationTree.branches.set(messageId, variants);
                
                // Re-render the message with layered variants
                const contentDiv = messageEl.querySelector('.message-content');
                contentDiv.innerHTML = createLayeredVariantsHTML(variants, messageId);
                messageEl.classList.add('has-variants');
                
                // Automatically select the new variant for branching with smooth transition
                setTimeout(() => {
                    setBranchSelection(messageId, variants.length - 1);
                    
                    // Ensure the new variant appears as active in the layered display
                    const variantsContainer = contentDiv.querySelector('.variants-container');
                    if (variantsContainer) {
                        const variantElements = variantsContainer.querySelectorAll('.response-variant');
                        variantElements.forEach((el, idx) => {
                            el.classList.toggle('active', idx === variants.length - 1);
                        });
                    }
                }, 200);
                
                // Save the updated conversation tree
                saveConversationTree();
                
            } catch (error) {
                console.error('Redo failed:', error);
                
                // Show error
                const errorMsg = addMessage(`Error generating variant: ${error.message}`, 'assistant');
                errorMsg.element.classList.add('error');
                
                // Remove error after a few seconds
                setTimeout(() => {
                    errorMsg.element.remove();
                }, 5000);
            } finally {
                // Reset redo button
                const messageEl = document.querySelector(`[data-message-id="${messageId}"]`);
                const redoBtn = messageEl?.querySelector('.redo-btn');
                if (redoBtn) {
                    redoBtn.textContent = 'redo';
                    redoBtn.disabled = false;
                }
            }
        }

        // Function to handle streaming response from DeepSeek
        async function processStreamingResponse(response, thinkingContainer, responseContainer) {
            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            
            let buffer = '';
            let isThinkingPhase = true;
            let thinkingText = '';
            let responseText = '';
            
            try {
                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    
                    buffer += decoder.decode(value, { stream: true });
                    const lines = buffer.split('\n');
                    
                    // Keep the last incomplete line in buffer
                    buffer = lines.pop() || '';
                    
                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            const data = line.slice(6);
                            if (data === '[DONE]') continue;
                            
                            try {
                                const parsed = JSON.parse(data);
                                const delta = parsed.choices?.[0]?.delta;
                                
                                if (delta?.reasoning_content) {
                                    // This is thinking content
                                    const newThinking = delta.reasoning_content;
                                    thinkingText += newThinking;
                                    
                                    // Animate the new thinking tokens
                                    if (thinkingContainer) {
                                        await animateThinkingToken(thinkingContainer, newThinking);
                                    }
                                } else if (delta?.content) {
                                    // This is the final response
                                    if (isThinkingPhase) {
                                        // Mark thinking as complete
                                        isThinkingPhase = false;
                                        if (thinkingContainer) {
                                            thinkingContainer.classList.add('thinking-complete');
                                        }
                                    }
                                    
                                    const newContent = delta.content;
                                    responseText += newContent;
                                    
                                    // Update response content with markdown rendering
                                    if (responseContainer) {
                                        responseContainer.innerHTML = marked.parse(responseText);
                                    }
                                }
                            } catch (e) {
                                // Skip malformed JSON
                                continue;
                            }
                        }
                    }
                }
            } catch (error) {
                console.error('Streaming error:', error);
                throw error;
            }
            
            return { thinkingText, responseText };
        }

        // Enhanced AI response generation for branch-aware conversations
        async function generateAIResponse() {
            const apiKey = apiKeyInput.value.trim();
            if (!apiKey) throw new Error('API key required');
            
            // Prepare API request using current path
            const systemPrompt = systemPromptInput.value.trim();
            const requestMessages = [];
            
            if (systemPrompt) {
                requestMessages.push({ role: 'system', content: systemPrompt });
            }
            
            // Convert current path messages to API format
            requestMessages.push(...getCurrentPath().map(msg => ({
                role: msg.role,
                content: msg.content
            })));
            
            // Set loading state
            isLoading = true;
            sendBtn.disabled = true;
            sendBtn.style.opacity = '0.3';
            sendBtn.textContent = 'thinking...';
            
            // Prepare containers for streaming content
            let thinkingContainer = null;
            let responseContainer = null;
            let thinkingMsgId = null;
            let responseMsgId = null;
            
            try {
                // Create thinking container if show thinking is enabled
                if (showThinkingCheckbox.checked) {
                    const thinkingMsg = addMessage('', 'assistant', true, true);
                    thinkingContainer = thinkingMsg.element.querySelector('.message-content');
                    thinkingMsgId = thinkingMsg.id;
                }
                
                // Create response container
                const responseMsg = addMessage('', 'assistant', false, true);
                responseContainer = responseMsg.element.querySelector('.message-content');
                responseMsgId = responseMsg.id;
                
                // Make streaming API call
                const response = await fetch('https://api.deepseek.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: 'deepseek-reasoner',
                        messages: requestMessages,
                        temperature: 0.6,
                        stream: true
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`API Error: ${response.status} ${response.statusText}`);
                }
                
                // Process the streaming response
                const { thinkingText, responseText } = await processStreamingResponse(
                    response, 
                    thinkingContainer, 
                    responseContainer
                );
                
                // Add the final response to the current conversation path
                const newResponse = {
                    id: responseMsgId,
                    role: 'assistant',
                    content: responseText,
                    thinking: thinkingText
                };
                
                const updatedPath = [...getCurrentPath(), newResponse];
                updateCurrentPath(updatedPath);
                conversationTree.messages = updatedPath;
                
                // Update send button
                sendBtn.textContent = 'complete';
                setTimeout(() => {
                    sendBtn.textContent = 'send';
                }, 1000);
                
            } catch (error) {
                // Remove partial streaming containers
                if (thinkingContainer) {
                    thinkingContainer.closest('.message').remove();
                }
                if (responseContainer) {
                    responseContainer.closest('.message').remove();
                }
                throw error;
            } finally {
                // Reset loading state
                setTimeout(() => {
                    isLoading = false;
                    sendBtn.disabled = false;
                    sendBtn.style.opacity = '1';
                    if (sendBtn.textContent !== 'complete') {
                        sendBtn.textContent = 'send';
                    }
                    messageInput.focus();
                }, 200);
            }
        }

        // Function to animate text tokens appearing in real-time
        function animateThinkingToken(container, text, delay = 0) {
            return new Promise((resolve) => {
                setTimeout(() => {
                    // Split text into words for natural animation pacing
                    const words = text.split(' ');
                    
                    words.forEach((word, index) => {
                        setTimeout(() => {
                            const span = document.createElement('span');
                            span.className = 'thinking-token';
                            span.textContent = word + (index < words.length - 1 ? ' ' : '');
                            
                            // Insert before cursor
                            const cursor = container.querySelector('.thinking-cursor');
                            if (cursor) {
                                container.insertBefore(span, cursor);
                            } else {
                                container.appendChild(span);
                            }
                            
                            // Auto-scroll to keep cursor in view
                            setTimeout(() => {
                                chatContainer.scrollTo({
                                    top: chatContainer.scrollHeight,
                                    behavior: 'smooth'
                                });
                            }, 50);
                            
                            // Resolve when last word is added
                            if (index === words.length - 1) {
                                resolve();
                            }
                        }, index * 60); // 60ms between words feels natural
                    });
                }, delay);
            });
        }

        // Enhanced export function with multi-path and branch selection support
        function exportChat() {
            // Save current state first
            saveConversationTree();
            
            const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
            
            // Create comprehensive export data including all paths and branch selections
            const exportData = {
                metadata: {
                    title: 'harpoon - Conversation Tree',
                    exported: new Date().toISOString(),
                    systemPrompt: systemPromptInput.value.trim(),
                    currentPath: conversationTree.currentPath,
                    branchSelection: conversationTree.branchSelection
                },
                conversation: {
                    messages: conversationTree.messages, // Current path for compatibility
                    branches: Array.from(conversationTree.branches.entries()),
                    paths: Array.from(conversationTree.paths.entries()),
                    messageIdCounter: conversationTree.messageIdCounter,
                    pathCounter: conversationTree.pathCounter,
                    branchSelection: conversationTree.branchSelection
                }
            };
            
            // Export as JSON for reimport
            const jsonBlob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const jsonUrl = URL.createObjectURL(jsonBlob);
            const jsonLink = document.createElement('a');
            jsonLink.href = jsonUrl;
            jsonLink.download = `deepseek-tree-${timestamp}.json`;
            document.body.appendChild(jsonLink);
            jsonLink.click();
            document.body.removeChild(jsonLink);
            URL.revokeObjectURL(jsonUrl);
            
            // Also create a visual HTML export with all paths
            setTimeout(() => {
                createVisualExport(exportData, timestamp);
            }, 500);
            
            // Visual feedback
            exportBtn.style.transform = 'translateY(-2px)';
            exportBtn.textContent = 'exported';
            setTimeout(() => {
                exportBtn.style.transform = '';
                exportBtn.textContent = 'export';
            }, 2000);
        }

        function createVisualExport(data, timestamp) {
            const htmlContent = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DeepSeek R1 Conversation Export</title>
    <style>
        body { 
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; 
            background: linear-gradient(180deg, #0a0a0a 0%, #1a1a1a 100%);
            color: #e8e8e8; 
            margin: 0; 
            padding: 2rem;
            line-height: 1.6;
        }
        .header { 
            text-align: center; 
            margin-bottom: 3rem; 
            border-bottom: 1px solid rgba(255,255,255,0.1);
            padding-bottom: 2rem;
        }
        .header h1 { 
            font-size: 2.5rem; 
            font-weight: 100; 
            color: #ffffff; 
            margin-bottom: 1rem;
        }
        .system-prompt { 
            background: rgba(255,255,255,0.05); 
            padding: 1.5rem; 
            border-radius: 8px; 
            margin: 2rem 0;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .path-section {
            margin: 3rem 0;
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 8px;
            overflow: hidden;
        }
        .path-header {
            background: rgba(255,255,255,0.05);
            padding: 1rem 1.5rem;
            font-weight: 400;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        .path-header.active {
            background: rgba(116, 59, 237, 0.2);
        }
        .message { 
            margin: 2rem 1.5rem; 
            padding: 1.5rem; 
            border-radius: 8px; 
            border: 1px solid rgba(255,255,255,0.1);
        }
        .message.user { 
            background: rgba(58, 123, 213, 0.1); 
            margin-left: 3rem; 
        }
        .message.assistant { 
            background: rgba(255,255,255,0.03); 
            margin-right: 3rem; 
        }
        .message.thinking { 
            background: rgba(139, 69, 195, 0.1); 
            font-family: 'Courier New', monospace; 
            font-size: 0.9rem; 
        }
        .message-label { 
            font-size: 0.8rem; 
            font-weight: 600; 
            opacity: 0.7; 
            text-transform: uppercase; 
            margin-bottom: 0.5rem; 
        }
        .branch-selected {
            border-color: rgba(116, 59, 237, 0.6) !important;
            background: rgba(116, 59, 237, 0.1) !important;
        }
        .variants { 
            margin: 1rem 0; 
            padding: 1rem; 
            background: rgba(255,255,255,0.02); 
            border-radius: 6px; 
            border-left: 3px solid rgba(255,255,255,0.2);
        }
        .variant { 
            margin: 1rem 0; 
            padding: 1rem; 
            background: rgba(255,255,255,0.05); 
            border-radius: 4px; 
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>harpoon - Conversation Tree</h1>
        <p>Exported on ${new Date().toLocaleString()}</p>
        <p><strong>Active Path:</strong> ${data.metadata.currentPath}</p>
        ${data.metadata.branchSelection ? `<p><strong>Branch Selection:</strong> Message ${data.metadata.branchSelection.messageId}, Variant ${data.metadata.branchSelection.variantIndex + 1}</p>` : ''}
        ${data.metadata.systemPrompt ? `<div class="system-prompt"><strong>System Prompt:</strong><br>${data.metadata.systemPrompt}</div>` : ''}
    </div>
    ${generateMultiPathHTML(data.conversation)}
</body>
</html>`;
            
            const htmlBlob = new Blob([htmlContent], { type: 'text/html' });
            const htmlUrl = URL.createObjectURL(htmlBlob);
            const htmlLink = document.createElement('a');
            htmlLink.href = htmlUrl;
            htmlLink.download = `deepseek-visual-${timestamp}.html`;
            document.body.appendChild(htmlLink);
            htmlLink.click();
            document.body.removeChild(htmlLink);
            URL.revokeObjectURL(htmlUrl);
        }

        function generateMultiPathHTML(conversation) {
            let html = '';
            
            // Generate HTML for each conversation path
            const paths = new Map(conversation.paths);
            const currentPath = conversation.messages;
            const branchSelection = conversation.branchSelection;
            
            for (const [pathId, pathMessages] of paths.entries()) {
                const isActivePath = JSON.stringify(pathMessages) === JSON.stringify(currentPath);
                
                html += `
                    <div class="path-section">
                        <div class="path-header ${isActivePath ? 'active' : ''}">
                            <strong>Conversation Thread: ${pathId}</strong>
                            ${isActivePath ? ' (Active)' : ''}
                            <span style="float: right; opacity: 0.6;">${pathMessages.length} messages</span>
                        </div>
                `;
                
                pathMessages.forEach(msg => {
                    const messageClass = msg.role === 'user' ? 'user' : 'assistant';
                    const label = msg.role === 'user' ? 'You' : 'Assistant';
                    const isBranchSelected = branchSelection && branchSelection.messageId === msg.id;
                    
                    // Add thinking if it exists
                    if (msg.thinking) {
                        html += `
                            <div class="message thinking">
                                <div class="message-label">Thinking</div>
                                <div class="message-content">${escapeHtml(msg.thinking)}</div>
                            </div>
                        `;
                    }
                    
                    // Add main message
                    html += `
                        <div class="message ${messageClass} ${isBranchSelected ? 'branch-selected' : ''}">
                            <div class="message-label">${label}${isBranchSelected ? ' (Branch Point)' : ''}</div>
                            <div class="message-content">${msg.role === 'assistant' ? marked.parse(msg.content) : escapeHtml(msg.content)}</div>
                        </div>
                    `;
                });
                
                html += '</div>';
            }
            
            return html;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Import function for JSON files with branch selection support
        function importConversation(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    
                    // Validate the import data
                    if (data.conversation && data.conversation.messages) {
                        // Restore the conversation tree with branch selection
                        conversationTree = {
                            messages: data.conversation.messages,
                            branches: new Map(data.conversation.branches || []),
                            paths: new Map(data.conversation.paths || [['main', data.conversation.messages]]),
                            currentPath: data.conversation.currentPath || data.metadata?.currentPath || 'main',
                            messageIdCounter: data.conversation.messageIdCounter || 0,
                            pathCounter: data.conversation.pathCounter || 0,
                            branchSelection: data.conversation.branchSelection || data.metadata?.branchSelection || null
                        };
                        
                        // Restore system prompt
                        if (data.metadata && data.metadata.systemPrompt) {
                            systemPromptInput.value = data.metadata.systemPrompt;
                        }
                        
                        // Rebuild the UI
                        rebuildChatFromTree();
                        updatePathIndicator();
                        updatePathSwitcher();
                        updateBranchContext();
                        
                        // Save to localStorage
                        saveConversationTree();
                        
                        console.log('Conversation imported successfully');
                    } else {
                        throw new Error('Invalid conversation file format');
                    }
                } catch (error) {
                    console.error('Import failed:', error);
                    alert('Failed to import conversation. Please check the file format.');
                }
            };
            reader.readAsText(file);
        }

        // Initialize the interface with enhanced branch-aware functionality
        setTimeout(() => {
            restoreHeaderState(); // Restore the header collapse state
            
            // Try to load saved conversation
            const hasLoadedConversation = loadConversationTree();
            
            if (!hasLoadedConversation) {
                messageInput.focus();
            }
            
            // Auto-save conversation tree periodically
            setInterval(() => {
                if (conversationTree.messages.length > 0) {
                    saveConversationTree();
                }
            }, 30000); // Save every 30 seconds
        }, 1000);

        // Auto-save when messages are added or branch selection changes
        const originalPush = conversationTree.messages.push;
        conversationTree.messages.push = function(...args) {
            const result = originalPush.apply(this, args);
            saveConversationTree();
            return result;
        };

        // Make import function available globally
        window.importConversation = importConversation;
    </script>
</body>
</html>
