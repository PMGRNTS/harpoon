<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>harpoon</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'><rect width='32' height='32' fill='%23743bed'/><rect x='4' y='8' width='24' height='16' fill='none' stroke='%23ffffff' stroke-width='1.5'/><rect x='6' y='10' width='20' height='4' fill='%23ffffff' opacity='0.3'/><rect x='6' y='18' width='20' height='4' fill='%23ffffff' opacity='0.3'/><circle cx='10' cy='16' r='1.5' fill='%23ffffff'/><line x1='12' y1='16' x2='16' y2='12' stroke='%23ffffff' stroke-width='1'/><line x1='12' y1='16' x2='16' y2='20' stroke='%23ffffff' stroke-width='1'/><line x1='16' y1='12' x2='20' y2='16' stroke='%23ffffff' stroke-width='1'/><line x1='16' y1='20' x2='20' y2='16' stroke='%23ffffff' stroke-width='1'/><circle cx='20' cy='16' r='1.5' fill='%23ffffff'/></svg>">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/4.3.0/marked.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
            font-weight: 300;
            background: linear-gradient(180deg, #0a0a0f 0%, #1a1a1f 100%);
            color: #e8e8e8;
            height: 100vh;
            display: flex;
            flex-direction: column;
            font-size: 16px;
            line-height: 1.6;
        }

        .header {
            padding: 3rem 3rem 2rem 3rem;
            background: linear-gradient(180deg, rgba(26,26,26,0.95) 0%, rgba(26,26,26,0) 100%);
            backdrop-filter: blur(20px);
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            overflow: hidden;
        }

        .header.collapsed {
            padding: 1.5rem 3rem;
        }

        .header h1 {
            font-size: 2.5rem;
            font-weight: 100;
            color: #ffffff;
            margin-bottom: 2rem;
            letter-spacing: -0.02em;
            opacity: 0;
            animation: fadeInUp 0.8s ease forwards;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }

        .header h1:hover {
            color: rgba(255,255,255,0.8);
        }

        .header h1::after {
            content: '⌄';
            position: absolute;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            font-size: 1.5rem;
            opacity: 0.5;
            transition: all 0.3s ease;
        }

        .header.collapsed h1::after {
            transform: translateY(-50%) rotate(-90deg);
        }

        .header-config {
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            transform-origin: top;
        }

        .header.collapsed .header-config {
            opacity: 0;
            transform: scaleY(0);
            height: 0;
            margin: 0;
            overflow: hidden;
        }

        .system-prompt {
            width: 100%;
            background: transparent;
            border: none;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            padding: 1rem 0;
            color: #e8e8e8;
            font-size: 1rem;
            font-weight: 300;
            resize: none;
            min-height: 60px;
            font-family: inherit;
            transition: all 0.3s ease;
            opacity: 0;
            animation: fadeInUp 0.8s ease 0.2s forwards;
        }

        .system-prompt:focus {
            outline: none;
            border-bottom-color: rgba(255,255,255,0.3);
            color: #ffffff;
        }

        .system-prompt::placeholder {
            color: rgba(255,255,255,0.4);
            font-weight: 300;
        }

        .api-key-input {
            width: 100%;
            background: transparent;
            border: none;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            padding: 1rem 0;
            color: #e8e8e8;
            font-size: 1rem;
            font-weight: 300;
            margin-top: 1.5rem;
            font-family: inherit;
            transition: all 0.3s ease;
            opacity: 0;
            animation: fadeInUp 0.8s ease 0.4s forwards;
        }

        .api-key-input:focus {
            outline: none;
            border-bottom-color: rgba(255,255,255,0.3);
            color: #ffffff;
        }

        .api-key-input::placeholder {
            color: rgba(255,255,255,0.4);
            font-weight: 300;
        }

        .thinking-toggle {
            display: flex;
            align-items: center;
            gap: 1rem;
            font-size: 0.9rem;
            font-weight: 300;
            margin-top: 2rem;
            opacity: 0;
            animation: fadeInUp 0.8s ease 0.6s forwards;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .thinking-toggle:hover {
            color: #ffffff;
        }

        .thinking-toggle input[type="checkbox"] {
            width: 18px;
            height: 18px;
            background: transparent;
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 2px;
            cursor: pointer;
            transition: all 0.3s ease;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            position: relative;
        }

        .thinking-toggle input[type="checkbox"]:checked {
            background: rgba(255,255,255,0.1);
            border-color: rgba(255,255,255,0.4);
        }

        .thinking-toggle input[type="checkbox"]:checked::after {
            content: '✓';
            position: absolute;
            top: -2px;
            left: 2px;
            color: rgba(255,255,255,0.8);
            font-size: 12px;
            font-weight: 400;
        }

        .chat-container {
            flex: 1;
            overflow-y: auto;
            padding: 1rem 3rem 1rem 3rem;
            display: flex;
            flex-direction: column;
            gap: 2rem;
        }

        .message {
            max-width: 100%;
            transition: all 0.5s ease;
            transform: translateY(20px);
            opacity: 0;
            animation: slideInFade 0.6s ease forwards;
            position: relative;
        }

        .message.user {
            text-align: right;
            margin-left: 20%;
        }

        .message.assistant, .message.thinking {
            text-align: left;
            margin-right: 20%;
        }

        .message.thinking {
            opacity: 0.7;
        }

        /* Branch from indicator */
        .message.branch-selected {
            position: relative;
        }

        .message.branch-selected::before {
            content: '↳ continue from here';
            position: absolute;
            top: -1.5rem;
            right: 0;
            font-size: 0.7rem;
            color: rgba(116, 59, 237, 0.8);
            font-weight: 400;
            letter-spacing: 0.05em;
            text-transform: uppercase;
            opacity: 0;
            animation: fadeInUp 0.3s ease forwards;
        }

        .branch-indicator {
            position: absolute;
            left: -2rem;
            top: 50%;
            transform: translateY(-50%);
            width: 12px;
            height: 12px;
            border: 2px solid rgba(116, 59, 237, 0.6);
            border-radius: 50%;
            background: rgba(116, 59, 237, 0.1);
            opacity: 0;
            transition: all 0.3s ease;
        }

        .message.branch-selected .branch-indicator {
            opacity: 1;
            background: rgba(116, 59, 237, 0.3);
            border-color: rgba(116, 59, 237, 0.8);
        }

        .message-label {
            font-size: 0.8rem;
            font-weight: 400;
            margin-bottom: 0.8rem;
            opacity: 0.6;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            transition: all 0.3s ease;
        }

        .message.user .message-label {
            color: rgba(255,255,255,0.5);
        }

        .message.assistant .message-label {
            color: rgba(255,255,255,0.5);
        }

        .message.thinking .message-label {
            color: rgba(255,255,255,0.4);
        }

        .message-content {
            font-size: 1rem;
            font-weight: 300;
            line-height: 1.7;
            transition: all 0.3s ease;
        }

        .message.thinking .message-content {
            font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Fira Code', monospace;
            font-size: 0.9rem;
            opacity: 0.8;
            white-space: pre-wrap;
            line-height: 1.6;
        }

        /* Real-time thinking animation styles */
        .thinking-token {
            opacity: 0;
            transform: translateY(8px);
            animation: thinkingFadeIn 0.6s ease forwards;
            display: inline;
        }

        .thinking-cursor {
            display: inline-block;
            width: 2px;
            height: 1.2em;
            background: rgba(255,255,255,0.5);
            margin-left: 2px;
            animation: pulse 1s ease-in-out infinite;
            vertical-align: text-bottom;
        }

        @keyframes thinkingFadeIn {
            to {
                opacity: 0.8;
                transform: translateY(0);
            }
        }

        @keyframes pulse {
            0%, 50% { opacity: 0.5; }
            25%, 75% { opacity: 0.8; }
        }

        .thinking-complete .thinking-cursor {
            display: none;
        }

        .message-content h1, .message-content h2, .message-content h3 {
            margin: 2rem 0 1rem 0;
            color: #ffffff;
            font-weight: 300;
            letter-spacing: -0.01em;
        }

        .message-content h1 { font-size: 1.8rem; }
        .message-content h2 { font-size: 1.4rem; }
        .message-content h3 { font-size: 1.2rem; }

        .message-content p {
            margin: 1rem 0;
        }

        .message-content pre {
            background: rgba(255,255,255,0.02);
            border-radius: 8px;
            padding: 1.5rem;
            overflow-x: auto;
            margin: 2rem 0;
            font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Fira Code', monospace;
            border: 1px solid rgba(255,255,255,0.05);
        }

        .message-content code {
            background: rgba(255,255,255,0.08);
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Fira Code', monospace;
            font-size: 0.9em;
        }

        .message-content pre code {
            background: none;
            padding: 0;
        }

        .input-area {
            padding: 1.5rem 3rem 2rem 3rem;
            background: linear-gradient(0deg, rgba(26,26,26,0.95) 0%, rgba(26,26,26,0) 100%);
            backdrop-filter: blur(20px);
            display: flex;
            gap: 2rem;
            align-items: flex-end;
            position: relative;
        }

        /* Branch context indicator */
        .branch-context {
            position: absolute;
            top: 0.5rem;
            left: 3rem;
            right: 3rem;
            text-align: center;
            font-size: 0.8rem;
            color: rgba(116, 59, 237, 0.8);
            font-weight: 300;
            opacity: 0;
            transform: translateY(-10px);
            transition: all 0.3s ease;
            pointer-events: none;
        }

        .branch-context.active {
            opacity: 1;
            transform: translateY(0);
        }

        .message-input {
            flex: 1;
            background: transparent;
            border: none;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            padding: 1rem 0;
            color: #e8e8e8;
            resize: none;
            min-height: 24px;
            max-height: 120px;
            font-size: 1rem;
            font-weight: 300;
            font-family: inherit;
            transition: all 0.3s ease;
        }

        .message-input:focus {
            outline: none;
            border-bottom-color: rgba(255,255,255,0.3);
            color: #ffffff;
        }

        .message-input::placeholder {
            color: rgba(255,255,255,0.4);
            font-weight: 300;
        }

        .btn {
            background: none;
            color: rgba(255,255,255,0.6);
            border: none;
            padding: 1rem 0;
            cursor: pointer;
            font-weight: 300;
            font-size: 1rem;
            font-family: inherit;
            transition: all 0.3s ease;
            position: relative;
            min-width: 80px;
        }

        .btn:hover {
            color: #ffffff;
            transform: translateY(-1px);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn:disabled {
            color: rgba(255,255,255,0.2);
            cursor: not-allowed;
            transform: none;
        }

        .btn::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            width: 0;
            height: 1px;
            background: rgba(255,255,255,0.3);
            transition: width 0.3s ease;
        }

        .btn:hover::after {
            width: 100%;
        }

        .controls {
            display: flex;
            gap: 2rem;
            align-items: flex-end;
        }

        .error {
            color: #ff6b6b !important;
        }

        .error .message-label {
            color: rgba(255, 107, 107, 0.6) !important;
        }

        /* Confirmation Modal */
        .confirmation-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.8);
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
            z-index: 1000;
        }

        .confirmation-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .confirmation-modal {
            background: linear-gradient(180deg, #1a1a1a 0%, #0f0f0f 100%);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 12px;
            padding: 3rem;
            max-width: 400px;
            text-align: center;
            transform: translateY(20px) scale(0.9);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .confirmation-overlay.active .confirmation-modal {
            transform: translateY(0) scale(1);
        }

        .confirmation-modal h3 {
            font-size: 1.5rem;
            font-weight: 300;
            color: #ffffff;
            margin-bottom: 1rem;
            letter-spacing: -0.01em;
        }

        .confirmation-modal p {
            font-size: 1rem;
            font-weight: 300;
            color: rgba(255,255,255,0.7);
            margin-bottom: 2rem;
            line-height: 1.6;
        }

        .confirmation-actions {
            display: flex;
            gap: 2rem;
            justify-content: center;
        }

        .confirmation-btn {
            background: none;
            border: none;
            padding: 0.75rem 1.5rem;
            font-size: 1rem;
            font-weight: 300;
            font-family: inherit;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }

        .confirmation-btn.cancel {
            color: rgba(255,255,255,0.6);
        }

        .confirmation-btn.confirm {
            color: #ff6b6b;
        }

        .confirmation-btn:hover {
            transform: translateY(-1px);
        }

        .confirmation-btn::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            width: 0;
            height: 1px;
            background: currentColor;
            transition: width 0.3s ease;
        }

        .confirmation-btn:hover::after {
            width: 100%;
        }

        /* Conversation path indicator */
        .path-indicator {
            position: absolute;
            top: 1rem;
            right: 3rem;
            font-size: 0.8rem;
            color: rgba(255,255,255,0.4);
            font-weight: 300;
            opacity: 0;
            transition: all 0.3s ease;
            pointer-events: none;
        }

        .header:not(.collapsed) .path-indicator {
            opacity: 1;
        }

        .path-switcher {
            margin-top: 0.5rem;
            display: flex;
            gap: 1rem;
            align-items: center;
            opacity: 0;
            transition: all 0.3s ease;
        }

        .path-switcher.visible {
            opacity: 1;
        }

        .path-btn {
            background: none;
            border: none;
            color: rgba(255,255,255,0.5);
            font-size: 0.8rem;
            font-weight: 300;
            font-family: inherit;
            cursor: pointer;
            padding: 0.25rem 0.5rem;
            transition: all 0.3s ease;
            position: relative;
        }

        .path-btn.active {
            color: rgba(255,255,255,0.8);
        }

        .path-btn:hover {
            color: rgba(255,255,255,0.9);
            transform: translateY(-1px);
        }

        .path-btn::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            width: 0;
            height: 1px;
            background: currentColor;
            transition: width 0.3s ease;
        }

        .path-btn:hover::after,
        .path-btn.active::after {
            width: 100%;
        }

        /* Response variants and redo functionality */
        .message-actions {
            opacity: 0;
            transition: all 0.3s ease;
            margin-top: 0.5rem;
            display: flex;
            gap: 1rem;
            justify-content: flex-end;
            align-items: center;
        }

        .message.assistant:hover .message-actions {
            opacity: 1;
        }

        .message-btn {
            background: none;
            border: none;
            color: rgba(255,255,255,0.4);
            font-size: 0.8rem;
            font-weight: 300;
            font-family: inherit;
            cursor: pointer;
            padding: 0.25rem 0.5rem;
            transition: all 0.3s ease;
            position: relative;
        }

        .message-btn:hover {
            color: rgba(255,255,255,0.8);
            transform: translateY(-1px);
        }

        .message-btn::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            width: 0;
            height: 1px;
            background: currentColor;
            transition: width 0.3s ease;
        }

        .message-btn:hover::after {
            width: 100%;
        }

        .branch-indicator {
            font-size: 0.8rem;
            color: rgba(255,255,255,0.3);
            font-weight: 300;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .branch-nav {
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .branch-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: rgba(255,255,255,0.2);
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .branch-dot.active {
            background: rgba(255,255,255,0.6);
            transform: scale(1.2);
        }

        /* ======= SIMPLIFIED LAYERED VARIANTS SYSTEM - MAX 3 VARIANTS ======= */
        
        /* Container for layered responses */
        .variants-container {
            position: relative;
            min-height: 200px; /* Ensure space for layered effect */
            margin: 1rem 0;
        }

        /* Individual variant layers */
        .response-variant {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            background: none;
            border: none;
            border-radius: 8px;
            padding: 1.5rem;
            cursor: pointer;
            transition: all 0.8s cubic-bezier(0.4, 0, 0.2, 1);
            transform-origin: center;
            backface-visibility: hidden;
            will-change: transform, opacity, filter;
        }

        /* Active variant (front layer) */
        .response-variant.active {
            opacity: 1;
            transform: translateX(0) translateY(0) scale(1);
            z-index: 10;
            filter: blur(0px);
        }

        /* First inactive variant - blurred, translucent, offset but selectable */
        .response-variant.variant-1 {
            opacity: 0.3;
            transform: translateX(120px) translateY(60px) scale(0.8);
            z-index: 8;
            filter: blur(2px);
            pointer-events: all;
            cursor: pointer;
        }

        .response-variant.variant-1:hover {
            opacity: 0.5;
            transform: translateX(110px) translateY(50px) scale(0.82);
            filter: blur(1px);
        }

        /* Second inactive variant - smaller, more faded but still selectable */
        .response-variant.variant-2 {
            opacity: 0.15;
            transform: translateX(160px) translateY(90px) scale(0.65);
            z-index: 6;
            filter: blur(3px);
            pointer-events: all;
            cursor: pointer;
        }

        .response-variant.variant-2:hover {
            opacity: 0.35;
            transform: translateX(150px) translateY(80px) scale(0.68);
            filter: blur(2px);
        }

        /* Branch selected variant gets subtle highlighting only when active */
        .response-variant.branch-selected.active {
            box-shadow: 0 0 20px rgba(116, 59, 237, 0.1);
        }

        /* Enhanced message actions for variants */
        .message.has-variants .message-actions {
            position: relative;
            z-index: 15;
            margin-top: 2rem; /* Give space for the layered variants */
        }

        /* Smooth transitions for variant switching */
        .variants-container.switching .response-variant {
            transition: all 0.8s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* ======= END LAYERED VARIANTS SYSTEM ======= */

        /* Custom scrollbar */
        ::-webkit-scrollbar {
            width: 2px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(255,255,255,0.05);
            border-radius: 1px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(255,255,255,0.1);
        }

        /* Hide scrollbars in Firefox */
        * {
            scrollbar-width: thin;
            scrollbar-color: rgba(255,255,255,0.05) transparent;
        }

        /* Animations */
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes slideInFade {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .header, .chat-container, .input-area {
                padding-left: 1.5rem;
                padding-right: 1.5rem;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .message.user {
                margin-left: 10%;
            }
            
            .message.assistant, .message.thinking {
                margin-right: 10%;
            }

            /* Adjust layered effect for mobile - maintain dramatic offset */
            .response-variant:not(.active) {
                transform: translateX(100px) translateY(70px) scale(0.65);
            }

            .response-variant:not(.active):nth-child(3) {
                transform: translateX(120px) translateY(100px) scale(0.6);
            }
        }
    </style>
</head>
<body>
    <div class="header" id="header">
        <h1 id="headerToggle">harpoon</h1>
        <div class="path-indicator" id="pathIndicator">conversation thread: main</div>
        <div class="header-config">
            <textarea class="system-prompt" placeholder="system prompt">You are a helpful assistant.</textarea>
            <input type="password" class="api-key-input" placeholder="api key" id="apiKey">
            <label class="thinking-toggle">
                <input type="checkbox" id="showThinking" checked>
                <span>show thinking</span>
            </label>
            <div class="path-switcher" id="pathSwitcher">
                <span style="color: rgba(255,255,255,0.4); font-size: 0.8rem;">threads:</span>
                <button class="path-btn active" data-path="main">main</button>
            </div>
        </div>
    </div>

    <div class="chat-container" id="chatContainer">
        <!-- Messages will be added here -->
    </div>

    <div class="input-area">
        <div class="branch-context" id="branchContext">
            responding from selected variant
        </div>
        <textarea class="message-input" id="messageInput" placeholder="message" rows="1"></textarea>
        <div class="controls">
            <input type="file" id="importFile" accept=".json" style="display: none;" onchange="importConversation(event)">
            <button class="btn" onclick="document.getElementById('importFile').click()">import</button>
            <button class="btn" id="sendBtn">send</button>
            <button class="btn" id="refreshBtn">refresh</button>
            <button class="btn" id="exportBtn">export</button>
        </div>
    </div>

    <!-- Confirmation Modal -->
    <div class="confirmation-overlay" id="confirmationOverlay">
        <div class="confirmation-modal">
            <h3>Clear conversation?</h3>
            <p>This will remove all messages from your current chat session. This action cannot be undone.</p>
            <div class="confirmation-actions">
                <button class="confirmation-btn cancel" id="cancelBtn">cancel</button>
                <button class="confirmation-btn confirm" id="confirmBtn">clear</button>
            </div>
        </div>
    </div>

    <script>
        // Enhanced chat state management for conversation trees with branch selection
        let conversationTree = {
            messages: [], // Linear message history for current path
            branches: new Map(), // messageId -> [response variants]
            paths: new Map([['main', []]]), // pathId -> messages array
            currentPath: 'main', // Current active path
            messageIdCounter: 0,
            pathCounter: 0,
            branchSelection: null // { messageId, variantIndex } - selected point for branching
        };

        // Make import function available globally for onclick handler
        window.importConversation = importConversation;
        let isLoading = false;

        // DOM elements
        const chatContainer = document.getElementById('chatContainer');
        const messageInput = document.getElementById('messageInput');
        const sendBtn = document.getElementById('sendBtn');
        const refreshBtn = document.getElementById('refreshBtn');
        const exportBtn = document.getElementById('exportBtn');
        const apiKeyInput = document.getElementById('apiKey');
        const systemPromptInput = document.querySelector('.system-prompt');
        const showThinkingCheckbox = document.getElementById('showThinking');
        const header = document.getElementById('header');
        const headerToggle = document.getElementById('headerToggle');
        const confirmationOverlay = document.getElementById('confirmationOverlay');
        const cancelBtn = document.getElementById('cancelBtn');
        const confirmBtn = document.getElementById('confirmBtn');
        const pathIndicator = document.getElementById('pathIndicator');
        const pathSwitcher = document.getElementById('pathSwitcher');
        const branchContext = document.getElementById('branchContext');

        // Core path management functions
        function getCurrentPath() {
            return conversationTree.paths.get(conversationTree.currentPath) || [];
        }

        function updateCurrentPath(messages) {
            conversationTree.paths.set(conversationTree.currentPath, messages);
            updatePathIndicator();
        }

        function updatePathIndicator() {
            pathIndicator.textContent = `conversation thread: ${conversationTree.currentPath}`;
        }

        function switchToPath(pathId) {
            conversationTree.currentPath = pathId;
            conversationTree.messages = getCurrentPath();
            conversationTree.branchSelection = null; // Clear branch selection when switching paths
            updatePathIndicator();
            rebuildChatFromTree();
            updatePathSwitcher();
            updateBranchContext();
            saveConversationTree();
        }

        function createNewPathFromBranch(messageId, variantIndex) {
            // Find the message in the current conversation
            const currentPath = getCurrentPath();
            const messageIndex = currentPath.findIndex(msg => msg.id === messageId);
            if (messageIndex === -1) return null;

            // Get the conversation up to that point
            const conversationUpToBranch = currentPath.slice(0, messageIndex);
            
            // Get the selected variant
            const variants = conversationTree.branches.get(messageId);
            if (!variants || !variants[variantIndex]) return null;
            
            const selectedVariant = variants[variantIndex];
            
            // Create new path ID
            const newPathId = `branch_${++conversationTree.pathCounter}`;
            
            // Create the new path with conversation up to and including the selected variant
            const newPath = [...conversationUpToBranch, selectedVariant];
            conversationTree.paths.set(newPathId, newPath);
            
            return newPathId;
        }

        function updatePathSwitcher() {
            const pathBtns = pathSwitcher.querySelectorAll('.path-btn');
            pathBtns.forEach(btn => {
                btn.classList.toggle('active', btn.dataset.path === conversationTree.currentPath);
            });
            
            // Show switcher if there are multiple paths
            if (conversationTree.paths.size > 1) {
                pathSwitcher.classList.add('visible');
                
                // Add any new path buttons
                Array.from(conversationTree.paths.keys()).forEach(pathId => {
                    if (!pathSwitcher.querySelector(`[data-path="${pathId}"]`)) {
                        const btn = document.createElement('button');
                        btn.className = 'path-btn';
                        btn.dataset.path = pathId;
                        btn.textContent = pathId;
                        btn.onclick = () => switchToPath(pathId);
                        pathSwitcher.appendChild(btn);
                    }
                });
            }
        }

        // Branch selection management
        function setBranchSelection(messageId, variantIndex) {
            // Clear previous selection
            clearBranchSelection();
            
            // Set new selection
            conversationTree.branchSelection = { messageId, variantIndex };
            
            // Update UI
            updateBranchSelectionUI();
            updateBranchContext();
            saveConversationTree();
        }

        function clearBranchSelection() {
            conversationTree.branchSelection = null;
            
            // Clear UI indicators
            document.querySelectorAll('.message.branch-selected, .response-variant.branch-selected').forEach(el => {
                el.classList.remove('branch-selected');
            });
            
            // Restore any hidden messages when clearing branch selection
            restoreHiddenMessages();
            
            updateBranchContext();
        }

        function updateBranchSelectionUI() {
            if (!conversationTree.branchSelection) return;
            
            const { messageId, variantIndex } = conversationTree.branchSelection;
            const messageEl = document.querySelector(`[data-message-id="${messageId}"]`);
            
            if (messageEl) {
                messageEl.classList.add('branch-selected');
                
                // Add branch indicator if it doesn't exist
                if (!messageEl.querySelector('.branch-indicator')) {
                    const indicator = document.createElement('div');
                    indicator.className = 'branch-indicator';
                    messageEl.appendChild(indicator);
                }
                
                // Highlight the specific variant if there are multiple
                const variants = messageEl.querySelectorAll('.response-variant');
                if (variants.length > 0 && variants[variantIndex]) {
                    variants[variantIndex].classList.add('branch-selected');
                }
            }
        }

        function updateBranchContext() {
            if (conversationTree.branchSelection) {
                branchContext.classList.add('active');
            } else {
                branchContext.classList.remove('active');
            }
        }

        // Enhanced function to select a variant and handle chat branching
        function selectVariantForBranch(messageId, variantIndex) {
            const messageEl = document.querySelector(`[data-message-id="${messageId}"]`);
            if (!messageEl) return;
            
            const variantsContainer = messageEl.querySelector('.variants-container');
            if (!variantsContainer) return;
            
            // Get the variants for this message
            const variants = conversationTree.branches.get(messageId);
            if (!variants || !variants[variantIndex]) return;
            
            // Add switching class for enhanced transitions
            variantsContainer.classList.add('switching');
            
            // Update the conversation tree to use the selected variant
            const currentPath = getCurrentPath();
            const messageIndex = currentPath.findIndex(msg => msg.id === messageId);
            
            if (messageIndex !== -1) {
                // Replace the message in the current path with the selected variant
                const updatedPath = [...currentPath];
                updatedPath[messageIndex] = variants[variantIndex];
                
                // BRANCHING LOGIC: Truncate conversation at this point
                const truncatedPath = updatedPath.slice(0, messageIndex + 1);
                updateCurrentPath(truncatedPath);
                conversationTree.messages = truncatedPath;
                
                // Hide all messages that come after this branch point
                hideMessagesAfterBranchPoint(messageId);
            }
            
            // Set this variant as the branch selection point
            setBranchSelection(messageId, variantIndex);
            
            // Update visual layered state for variants with smooth transitions
            const variantElements = variantsContainer.querySelectorAll('.response-variant');
            variantElements.forEach((variant, index) => {
                // Remove active class from all
                variant.classList.remove('active', 'variant-1', 'variant-2');
                
                // Apply new positioning classes
                if (index === variantIndex) {
                    variant.classList.add('active');
                } else if (index === (variantIndex + 1) % variants.length) {
                    variant.classList.add('variant-1');
                } else if (index === (variantIndex + 2) % variants.length) {
                    variant.classList.add('variant-2');
                }
            });
            
            // Remove switching class after transition
            setTimeout(() => {
                variantsContainer.classList.remove('switching');
                saveConversationTree(); // Save the updated state
            }, 800);
            
            console.log(`Switched to variant ${variantIndex + 1} of message ${messageId} - Chat branched`);
        }
        
        // Function to hide messages that come after a branch point
        function hideMessagesAfterBranchPoint(branchMessageId) {
            const allMessages = chatContainer.querySelectorAll('.message');
            let foundBranchPoint = false;
            
            allMessages.forEach(messageEl => {
                if (messageEl.dataset.messageId === branchMessageId) {
                    foundBranchPoint = true;
                    return;
                }
                
                if (foundBranchPoint) {
                    // Store original state for restoration
                    if (!messageEl.dataset.originalDisplay) {
                        messageEl.dataset.originalDisplay = messageEl.style.display || 'block';
                    }
                    
                    // Hide with smooth transition
                    messageEl.style.transition = 'all 0.5s ease';
                    messageEl.style.opacity = '0';
                    messageEl.style.transform = 'translateY(-20px)';
                    
                    setTimeout(() => {
                        messageEl.style.display = 'none';
                    }, 500);
                }
            });
        }
        
        // Function to restore hidden messages when switching back
        function restoreHiddenMessages() {
            const allMessages = chatContainer.querySelectorAll('.message[data-original-display]');
            
            allMessages.forEach(messageEl => {
                messageEl.style.display = messageEl.dataset.originalDisplay || 'block';
                messageEl.style.transition = 'all 0.5s ease';
                messageEl.style.opacity = '1';
                messageEl.style.transform = 'translateY(0)';
                
                // Clean up stored state
                delete messageEl.dataset.originalDisplay;
            });
        }

        // Enhanced function to create layered variants HTML - pure ghost interaction, MAX 3 VARIANTS
        function createLayeredVariantsHTML(variants, messageId) {
            const containerDiv = document.createElement('div');
            containerDiv.className = 'variants-container';
            
            // Only handle up to 3 variants (original + 2 redos)
            const limitedVariants = variants.slice(0, 3);
            
            limitedVariants.forEach((variant, index) => {
                const variantDiv = document.createElement('div');
                // Apply proper variant classes for layered positioning
                let variantClass = 'response-variant';
                if (index === 0) {
                    variantClass += ' active';
                } else if (index === 1) {
                    variantClass += ' variant-1';
                } else if (index === 2) {
                    variantClass += ' variant-2';
                }
                
                variantDiv.className = variantClass;
                variantDiv.dataset.variantIndex = index;
                variantDiv.onclick = () => selectVariantForBranch(messageId, index);
                
                // Add variant content - NO BADGES, PURE CONTENT
                const contentDiv = document.createElement('div');
                contentDiv.innerHTML = marked.parse(variant.content);
                variantDiv.appendChild(contentDiv);
                
                containerDiv.appendChild(variantDiv);
            });
            
            return containerDiv.outerHTML;
        }

        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            // Try to load saved conversation
            if (loadConversationTree()) {
                console.log('Loaded saved conversation with branch support');
            }
            
            // Load saved API key
            const savedApiKey = localStorage.getItem('deepseekApiKey');
            if (savedApiKey) {
                apiKeyInput.value = savedApiKey;
            }
            
            // Save API key on change
            apiKeyInput.addEventListener('change', function() {
                if (this.value) {
                    localStorage.setItem('deepseekApiKey', this.value);
                } else {
                    localStorage.removeItem('deepseekApiKey');
                }
            });
            
            // Restore header collapse state
            restoreHeaderState();
            
            // Focus on message input
            messageInput.focus();
        });

        // Auto-resize textarea with smooth transitions
        messageInput.addEventListener('input', function() {
            this.style.height = 'auto';
            this.style.height = this.scrollHeight + 'px';
        });

        // Send message on Enter (Shift+Enter for new line)
        messageInput.addEventListener('keydown', function(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });

        // Button event handlers
        sendBtn.addEventListener('click', sendMessage);
        refreshBtn.addEventListener('click', showRefreshConfirmation);
        exportBtn.addEventListener('click', exportChat);

        // Header collapse functionality
        headerToggle.addEventListener('click', toggleHeader);

        // Confirmation modal handlers
        cancelBtn.addEventListener('click', hideRefreshConfirmation);
        confirmBtn.addEventListener('click', confirmRefresh);
        confirmationOverlay.addEventListener('click', function(e) {
            if (e.target === confirmationOverlay) {
                hideRefreshConfirmation();
            }
        });

        // Header collapse state management
        function toggleHeader() {
            header.classList.toggle('collapsed');
            // Save the collapsed state to localStorage for persistence
            const isCollapsed = header.classList.contains('collapsed');
            localStorage.setItem('headerCollapsed', isCollapsed);
        }

        // Restore header state on page load
        function restoreHeaderState() {
            const isCollapsed = localStorage.getItem('headerCollapsed') === 'true';
            if (isCollapsed) {
                header.classList.add('collapsed');
            }
        }

        // Refresh confirmation functions
        function showRefreshConfirmation() {
            confirmationOverlay.classList.add('active');
        }

        function hideRefreshConfirmation() {
            confirmationOverlay.classList.remove('active');
        }

        function confirmRefresh() {
            // Clear all conversation data and reset to initial state
            conversationTree = {
                messages: [],
                branches: new Map(),
                paths: new Map([['main', []]]),
                currentPath: 'main',
                messageIdCounter: 0,
                pathCounter: 0,
                branchSelection: null
            };
            chatContainer.innerHTML = '';
            hideRefreshConfirmation();
            
            // Reset UI indicators
            updatePathIndicator();
            updateBranchContext();
            pathSwitcher.classList.remove('visible');
            pathSwitcher.innerHTML = `
                <span style="color: rgba(255,255,255,0.4); font-size: 0.8rem;">threads:</span>
                <button class="path-btn active" data-path="main">main</button>
            `;
            
            // Clear persisted state
            localStorage.removeItem('deepseekConversationTree');
            
            // Provide subtle feedback
            refreshBtn.style.transform = 'translateY(-2px)';
            setTimeout(() => {
                refreshBtn.style.transform = '';
                messageInput.focus();
            }, 150);
        }

        // Enhanced persistence functions for branch-aware conversations
        function saveConversationTree() {
            try {
                const serializable = {
                    messages: conversationTree.messages,
                    branches: Array.from(conversationTree.branches.entries()),
                    paths: Array.from(conversationTree.paths.entries()),
                    currentPath: conversationTree.currentPath,
                    messageIdCounter: conversationTree.messageIdCounter,
                    pathCounter: conversationTree.pathCounter,
                    branchSelection: conversationTree.branchSelection,
                    systemPrompt: systemPromptInput.value,
                    timestamp: new Date().toISOString()
                };
                localStorage.setItem('deepseekConversationTree', JSON.stringify(serializable));
            } catch (error) {
                console.error('Failed to save conversation:', error);
            }
        }

        function loadConversationTree() {
            try {
                const saved = localStorage.getItem('deepseekConversationTree');
                if (!saved) return false;
                
                const data = JSON.parse(saved);
                
                // Restore conversation tree with branch selection
                conversationTree = {
                    messages: data.messages || [],
                    branches: new Map(data.branches || []),
                    paths: new Map(data.paths || [['main', data.messages || []]]),
                    currentPath: data.currentPath || 'main',
                    messageIdCounter: data.messageIdCounter || 0,
                    pathCounter: data.pathCounter || 0,
                    branchSelection: data.branchSelection || null
                };
                
                // Ensure current path exists
                if (!conversationTree.paths.has(conversationTree.currentPath)) {
                    conversationTree.currentPath = 'main';
                    if (!conversationTree.paths.has('main')) {
                        conversationTree.paths.set('main', []);
                    }
                }
                
                // Update messages to match current path
                conversationTree.messages = getCurrentPath();
                
                // Restore system prompt
                if (data.systemPrompt) {
                    systemPromptInput.value = data.systemPrompt;
                }
                
                // Rebuild UI
                rebuildChatFromTree();
                updatePathIndicator();
                updatePathSwitcher();
                updateBranchContext();
                
                return true;
            } catch (error) {
                console.error('Failed to load conversation:', error);
                return false;
            }
        }

        function rebuildChatFromTree() {
            chatContainer.innerHTML = '';
            
            // Use current path messages
            const currentMessages = getCurrentPath();
            
            currentMessages.forEach(msg => {
                if (msg.role === 'user') {
                    addMessage(msg.content, 'user', false, false, msg.id);
                } else if (msg.role === 'assistant') {
                    // Add thinking if it exists
                    if (msg.thinking && showThinkingCheckbox.checked) {
                        addMessage(msg.thinking, 'assistant', true, false, `${msg.id}_thinking`);
                    }
                    
                    // Check if this message has variants
                    const variants = conversationTree.branches.get(msg.id);
                    if (variants && variants.length > 1) {
                        // Find current variant index
                        const currentVariantIndex = variants.findIndex(v => v.content === msg.content);
                        addMessage(msg.content, 'assistant', false, false, msg.id, variants);
                        
                        // Set the correct variant as active
                        setTimeout(() => {
                            if (currentVariantIndex >= 0) {
                                const messageEl = document.querySelector(`[data-message-id="${msg.id}"]`);
                                if (messageEl) {
                                    const variantEls = messageEl.querySelectorAll('.response-variant');
                                    variantEls.forEach((el, idx) => {
                                        el.classList.toggle('active', idx === currentVariantIndex);
                                    });
                                }
                            }
                        }, 100);
                    } else {
                        // Add single response
                        addMessage(msg.content, 'assistant', false, false, msg.id);
                    }
                }
            });
            
            // Restore branch selection UI
            setTimeout(() => {
                updateBranchSelectionUI();
            }, 200);
        }

        // Enhanced function to add messages with layered variants and branch selection support
        function addMessage(content, role, isThinking = false, isStreaming = false, messageId = null, variants = null) {
            const msgId = messageId || `msg_${++conversationTree.messageIdCounter}`;
            
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${role}${isThinking ? ' thinking' : ''}`;
            messageDiv.dataset.messageId = msgId;
            
            const labelDiv = document.createElement('div');
            labelDiv.className = 'message-label';
            labelDiv.textContent = isThinking ? 'thinking' : (role === 'user' ? 'you' : 'assistant');
            
            const contentDiv = document.createElement('div');
            contentDiv.className = 'message-content';
            
            if (isStreaming) {
                contentDiv.innerHTML = '';
                if (isThinking) {
                    const cursor = document.createElement('span');
                    cursor.className = 'thinking-cursor';
                    contentDiv.appendChild(cursor);
                }
            } else {
                if (role === 'assistant' && !isThinking) {
                    // For assistant messages, handle variants with layered visual system
                    if (variants && variants.length > 1) {
                        contentDiv.innerHTML = createLayeredVariantsHTML(variants, msgId);
                        messageDiv.classList.add('has-variants');
                    } else {
                        contentDiv.innerHTML = marked.parse(content);
                    }
                } else {
                    contentDiv.textContent = content;
                }
            }
            
            messageDiv.appendChild(labelDiv);
            messageDiv.appendChild(contentDiv);
            
            // Add action buttons for assistant messages
            if (role === 'assistant' && !isThinking) {
                const actionsDiv = document.createElement('div');
                actionsDiv.className = 'message-actions';
                
                const redoBtn = document.createElement('button');
                redoBtn.className = 'message-btn redo-btn';
                redoBtn.textContent = 'redo';
                redoBtn.onclick = () => redoResponse(msgId);
                
                actionsDiv.appendChild(redoBtn);
                messageDiv.appendChild(actionsDiv);
            }
            
            chatContainer.appendChild(messageDiv);
            
            // Smooth scroll to bottom
            setTimeout(() => {
                chatContainer.scrollTo({
                    top: chatContainer.scrollHeight,
                    behavior: 'smooth'
                });
            }, 100);
            
            return { element: messageDiv, id: msgId };
        }

        // Export chat functionality  
        function exportChat() {
            try {
                const exportData = {
                    conversation: conversationTree,
                    systemPrompt: systemPromptInput.value,
                    exportDate: new Date().toISOString(),
                    version: '2.0'
                };
                
                const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `harpoon-chat-${new Date().toISOString().slice(0, 10)}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                // Visual feedback
                exportBtn.style.transform = 'translateY(-2px)';
                setTimeout(() => {
                    exportBtn.style.transform = '';
                }, 150);
            } catch (error) {
                console.error('Export failed:', error);
            }
        }

        // Import chat functionality
        function importConversation(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const importData = JSON.parse(e.target.result);
                    
                    if (importData.conversation) {
                        // Import the full conversation tree
                        conversationTree = {
                            messages: importData.conversation.messages || [],
                            branches: new Map(importData.conversation.branches || []),
                            paths: new Map(importData.conversation.paths || [['main', importData.conversation.messages || []]]),
                            currentPath: importData.conversation.currentPath || 'main',
                            messageIdCounter: importData.conversation.messageIdCounter || 0,
                            pathCounter: importData.conversation.pathCounter || 0,
                            branchSelection: importData.conversation.branchSelection || null
                        };
                        
                        // Update messages to match current path
                        conversationTree.messages = getCurrentPath();
                        
                        // Restore system prompt if available
                        if (importData.systemPrompt) {
                            systemPromptInput.value = importData.systemPrompt;
                        }
                        
                        // Rebuild the UI
                        rebuildChatFromTree();
                        updatePathIndicator();
                        updatePathSwitcher();
                        updateBranchContext();
                        
                        // Save the imported conversation
                        saveConversationTree();
                        
                        console.log('Successfully imported conversation with branch support');
                    }
                } catch (error) {
                    console.error('Import failed:', error);
                    alert('Failed to import conversation. Please check the file format.');
                }
            };
            reader.readAsText(file);
            
            // Clear the file input
            event.target.value = '';
        }

        // Placeholder functions for AI integration
        async function sendMessage() {
            console.log('Send message functionality would go here');
            // This function would handle sending messages and getting AI responses
        }

        async function redoResponse(messageId) {
            console.log('Redo response functionality would go here for message:', messageId);
            // This function would handle regenerating AI responses
        }
    </script>
</body>
</html>
